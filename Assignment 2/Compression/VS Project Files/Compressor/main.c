// This application is able to compress and decompress strings or files
// using Huffman encoding. Additionally using flags you can show the
// intermediate tree and dictionary, or see statistics about the input
// and output such as compression ratio and shannon entropy. Running
// the program with no arguments will provide full usage guidance.
// 
// TODO: Feature List
//--------------- Minimum -------------------
// - Input message or text file
//     - Flag for file -f
// - Construct binary Huffman Tree
// - Encode the input message / file
// - Output the encoded message
//     - Flag to output to a file -o
// - Output the dictionary
//     - Flag to output dictionary -d
//------------- Reasonable ------------------
// - Decoding messages or text files
//     - Flag for decode -r (reverse)
// - Additional statistics
//     - Flag for statistics -s
//     - Compression ratio inc/dis dictionary
//     - ?
// - How efficiently does the algorith compress different data types
// - How does the algorithm perform on very large datasets (books, csv, images, audio)
// - How does it perform on pre-compressed data. (ADD)
// - Shannons entropy.
//     - Of the input
//     - Compared to the output
//------------- Difficult  ------------------
// - Visualization of Huffman tree
// - Dictionary transmission protocols (ADD)
// - Use Hoffman code's for words in long texts (ADD)
// - Use Hoffman code's for variable sized data (Byte, short, int, long) (ADD)
// - Recursive Hoffman encoding? (ADD)
//
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// This is defined in Visual Studio, other compilers may or may not
//    define it..
#ifdef _WIN32
#include <Windows.h>
#endif

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef unsigned long long uint64;


// TODO: right is not needed since it is always left + 1
typedef struct TreeNode
{
	uint64 count;
	struct TreeNode* left;
	union
	{
		struct TreeNode* p;
		uint8 uint8Value;
		uint16 uint16Value;
		uint32 uint32Value;
		uint64 uint64Value;
	} right;
} TreeNode;

typedef struct
{
	uint64 map[256];
	uint64 count;
	uint16 uniqueCount;
} Uint8CountMap;

typedef struct
{
	TreeNode* root;
	Uint8CountMap* map;
} HuffmanTree;

typedef struct
{
	uint8 depth;
	uint32 code;
} HuffmanCode;

// Global unnamed struct instance to store statistics  
struct
{
	double compressionRatio;
	double shannonEntropy;
	double averageCodeLength;
	uint64 bytesBeforeEncoding;
	uint64 bitsAfterEncoding;
} stats = { 0 };

typedef enum
{
	CALLOC_FAILED = 0,
	FILE_NON_EXISTENT = 1,
	DEPTH_LIMIT_EXCEEDED = 2,
	UNIMPLEMENTED_ERROR = 3,
	MULTIPLE_INPUTS = 4,
	UNEXPECTED_ERROR = 5,
	NO_OUTPUT_FILE = 6,
	FILE_WRITE_FAILED =7
} ErrorCode;

const char* ErrorMessages[] =
{
	"A call to calloc failed! this should only happen if the OS can't return a block the size requested. "
	"Either your memory is completely full, incredibly fragmented, or something odd has happened!",
	"Filepath entered does not point to a file.",
	"The maximum supported length of a generated huffman code is 32bits, this has been exceeded!",
	"The feature you are trying to use is currently unimplemented!",
	"Only one input string is supported! Multiple were provided, if the input contains spaces, surround it with quotes.",
	"An infeasible error has occured, please try again, if this continues contact the creator of this program.",
	"Output flag was set but no file was provided!",
	"An error occured while writing to the output file"
};

// Flags and command line argument state.
bool dFlag = false;
bool tFlag = false;
bool oFlag = false; const char* output;
bool fFlag = false;
bool rFlag = false;
bool sFlag = false;
bool bFlag = false;
bool nFlag = false;
const char* input = 0;

void printUsage()
{
	printf("usage: comp [-b] [-s] [-t] "/*[-r]*/ "[-d] [-n] [-o <filepath>] [-f] <input>  \n\n");
	printf("<input> is interpreted as a string unless -f is provided.\n\n");
	printf("Flags: \n");
	printf("    -f Interpret <input> as a filepath and compress the file it points to.\n");
	printf("    -b Print the encoded message as a binary string.\n");
	printf("    -d Output the Huffman code dictionary internally generated by the program.\n");
	printf("    -s Generate and print additional statistics about the input, internal structures, and output\n");
	printf("    -t Output the Huffman tree internally generated to the console. (large trees may not display correctly)\n");
	//printf("    -r Decode the input, as this does not produce a Huffman tree the t flag is ignored.\n");
	printf("    -o <filepath> Write the encoded"/*/decoded*/ "message to the file pointed to by filepath.\n");
	printf("    -n Do not output the encoded message (Useful for gathering statistics).\n");
}

// Prints the error associated with the error code if the condition
//     is true and returns the condition. Cleans up error reporting.
bool printErrorIf(bool condition, ErrorCode error)
{
	if (condition)
		printf("Error: %s\n", ErrorMessages[error]);

	return condition;
}

// Basically an Assert with re-usable error codes rather than strings.
void fatalErrorIf(bool condition, ErrorCode error)
{
	if (printErrorIf(condition, error))
		exit(-1);
}

HuffmanTree createUint8HuffmanTree(Uint8CountMap* map)
{
	// Maximum nodes = n * 2
	TreeNode* nodes = calloc(map->uniqueCount * 2, sizeof(TreeNode));
	fatalErrorIf(nodes == NULL, CALLOC_FAILED);

	uint16 count = 0;
	uint8 symbol = 0;
	for (; count < map->uniqueCount; ++symbol)
	{
		// Find next symbol
		for (; symbol < 256; ++symbol)
			if (map->map[symbol] > 0) break;

		// Find insertion point
		uint8 i = count;
		for (; i > 0 && map->map[symbol] < nodes[i - 1].count; --i)
			memcpy(nodes + i, nodes + i - 1, sizeof(TreeNode));

		// Insert element
		nodes[i].count = map->map[symbol];
		nodes[i].left = 0;
		nodes[i].right.uint8Value = symbol;
		++count;
	}

	// Ok, so we are going to start using the nodes array from both ends.
	//    From the end of the array going backwards (right array) are the 
	//    sorted nodes from smallest to largest count and from the start
	//    of the array going forwards (left array) are the unsorted nodes 
	//    again from smallest to largest count. We can guarantee these will
	//    never overlap due to the binary tree at max having 2n nodes. Once
	//    the left array has 1 item we are done.
	uint16 rightTail = map->uniqueCount * 2 - 1;
	for (;count > 1; --count)
	{
		// Copy 2 elements to right array.
		memcpy(&nodes[rightTail--], nodes, sizeof(TreeNode));
		memcpy(&nodes[rightTail--], nodes + 1, sizeof(TreeNode));
		// Move left array left by 2 elements
		memcpy(nodes, nodes + 2, sizeof(TreeNode) * (count - 2));

		// Find insertion point
		uint64 newNodeCount = nodes[rightTail + 1].count + nodes[rightTail + 2].count;
		uint8 i = count - 2;
		for (; i > 0 && newNodeCount < nodes[i - 1].count; --i)
			memcpy(nodes + i, nodes + i - 1, sizeof(TreeNode));

		// Insert element
		nodes[i].count = newNodeCount;
		nodes[i].left = nodes + rightTail + 1;
		nodes[i].right.p = nodes + rightTail + 2;
	}

	HuffmanTree tree;
	tree.root = nodes;
	tree.map = map;
	return tree;
}

void destroyHuffmanTree(HuffmanTree* tree)
{
	free(tree->root);
}

Uint8CountMap createUint8CountMap(const char* string)
{
	Uint8CountMap map = { 0 };

	if (!fFlag)
	{
		for (const uint8* p = string; *p != '\0'; ++p)
		{
			
			if(map.map[*p]++ == 0) // Count occurances of *p
				++map.uniqueCount; // Count unique uint8's in string
			++map.count;           // Count total uint8's in string
		}
	}
	else
	{
		FILE* f = fopen(string, "rb");

		// No microsoft, f couldn't be 0 because we are checking right here
		//     Visual Studio has really gone downhill the last ~10 years...
		fatalErrorIf(f == NULL, FILE_NON_EXISTENT);
		
		uint8 buffer[1024];
		size_t bytesRead = fread(buffer, 1, 1024, f);
		while (bytesRead > 0)
		{
			for (int i = 0; i < bytesRead; ++i)
			{
				if(map.map[buffer[i]]++ == 0)// Count occurances of buffer[i] 
					++map.uniqueCount;       // Count unique uint8's in string
				++map.count;                 // Count total uint8's in string
			}

			if (bytesRead != 1024) break;

			bytesRead = fread(buffer, 1, 1024, f);
		}
		fclose(f);
	}

	if (sFlag)
	{
		for (uint16 i = 0; i < 256; ++i)
		{
			if (map.map[i] > 0)
			{
				double p = (double)map.map[i] / (double)map.count;
				stats.shannonEntropy -= p * log2(p);
			}
		}

		stats.bytesBeforeEncoding = (double)map.count;
	}

	return map;
}

void printHuffmanCode(HuffmanCode code)
{
	for (uint8 i = 1; i <= code.depth; ++i)
	{
		// TODO: Branchless
		printf((code.code & (1 << (code.depth - i))) > 0 ? "1" : "0");
	}
}

void _recurseUint8HuffmanTree(HuffmanCode* map, TreeNode* n, uint8 depth, uint32 code, uint32 lines, bool parse, bool print)
{
	// We have set a hard limit on huffman tree depth of 32 here..
	//    I believe this is a reasonable maximum consideriong that although the worst
	//    case is 255 bits anything beyond 32 bits is incredibly unlikely requiring
	//    over 4GiB of a repeating character among other unlikely characteristics.
	fatalErrorIf(depth > 32, DEPTH_LIMIT_EXCEEDED);
	HuffmanCode hCode = { depth, code };

	if (print)
	{
		if (depth > 0)
		{
			for (uint8 i = depth - 1; i > 0; --i)
			{
				if ((lines & ((uint32)1 << i)) != 0)
					printf(" %c ", 179);
				else
					printf("   ");
			}

			// Mod2 but we want to flip it so that it's 1 when it would
			// have been 0 and vice versa as it makes the logic easier.
			uint32 mod = (code % 2 + 1) % 2;

			// Branchless programming, we are changing what character we
			//    draw in the table based on the value of mod, where if
			//    mod == 0 we are at the start of a right branch.
			uint8 c = 192 + mod * 3;

			// Again, the next line will be 1 depth deeper, if it's a left
			//    branch we need to draw an up-down line otherwise a space.
			//    Essentialy lines is a bitmap that tells us what to draw.
			lines = (lines + mod) << 1;
			printf(" %c ", c);
		}
		if(n->left != 0)
			printf(" %llu\n", n->count);
		else
		{
			printf("%llu = (Symbol: %u, Code: ", n->count, n->right.uint8Value);
			printHuffmanCode(hCode);
			printf(")\n");
		}
	}
	
	if (n->left == 0)
	{
		if(parse)
			map[n->right.uint8Value] = hCode;
	}
	else
	{
		_recurseUint8HuffmanTree(map, n->left, ++depth, code << 1, lines, parse, print);
		_recurseUint8HuffmanTree(map, n->right.p, depth, (code << 1) + 1, lines, parse, print);
	}
		
}


void parseHuffmanTree(HuffmanCode * map, HuffmanTree* tree)
{
	_recurseUint8HuffmanTree(map, tree->root, 0, 0, 0, true, false);
}

void printHuffmanTree(HuffmanCode* map, HuffmanTree* tree)
{
	_recurseUint8HuffmanTree(map, tree->root, 0, 0, 0, false, true);
}

void insertCodeIntoBuffer(uint8** buffer, uint64* bitCount, uint8* bufferBit, HuffmanCode code)
{
	// This feels really inefficient but I wouldn't be surprised
	//    if the compiler can optimize this a lot.
	// TODO: Implement logically more optimal solution and evaluate
	//    any performance gain or loss.
	for (uint8 bit = code.depth; bit > 0; --bit)
	{
		// Append a single bit of the code to the buffer
		**buffer = (**buffer << 1) + ((code.code >> (bit - 1)) & (uint32)1);
		++(*bufferBit);
		++(*bitCount);

		if (*bufferBit < 8) continue;

		// If we reach the end of a byte move to the next byte in memory
		++(*buffer);
		*bufferBit = 0;
	}
}

void printBuffer(uint8* buffer, uint64 count)
{
	if (bFlag)
	{
		HuffmanCode code = { 0 };
		code.depth = 8;
		for (uint64 i = 0; i < count; ++i)
		{
			code.code = buffer[i];
			printHuffmanCode(code);
		}
	}
	else
	{
		for (uint64 i = 0; i < count; ++i)
			printf("%c", buffer[i]);
	}
}

void printBufferBits(uint8* buffer, uint64 count)
{
	uint64 bytes = count / 8;
	uint8 bits = count % 8;
	uint8 lastCode = buffer[bytes] >> (8 - bits);

	printBuffer(buffer, bytes);

	HuffmanCode last = { bits, lastCode};
	printHuffmanCode(last);
}

// TODO: Files
void encodeMessage(HuffmanCode* codeMap, uint64 characterCount)
{
	// Endianness makes this a little bit of a pain, ideally we would
	// insert more than 1bit at a time but, it's very fiddly.
	uint8 bufferBit = 0;
	uint64 bitsCount = 0;
	uint64 count = 0;
	FILE* inFile = 0;
	uint8 inFileBuffer[1024];
	uint16 inFileBufferCount = 0;
	FILE* outFile = 0;
	uint8 outBuffer[1032] = { 0 };
	uint16 outBufferCount = 0;
	uint8* pIn = input;
	uint8* pOut = outBuffer;

	if (fFlag)
	{
		inFile = fopen(input, "rb");
		fatalErrorIf(inFile == NULL, FILE_NON_EXISTENT);
		pIn = inFileBuffer;
		inFileBufferCount = fread(inFileBuffer, sizeof(uint8), 1024, inFile);
	}
	if (oFlag)
	{
		outFile = fopen(output, "wb");
		fatalErrorIf(outFile == NULL, FILE_NON_EXISTENT);
	}

	for (; count < characterCount; ++pIn)
	{
		if (fFlag && pIn >= (inFileBuffer + inFileBufferCount))
		{
			inFileBufferCount = fread(inFileBuffer, sizeof(uint8), 1024, inFile);
			pIn = inFileBuffer;

			// I think this can only happen if the file changed between
			//    us previously reading it and now since we know how
			//    many bytes we should be reading..?
			fatalErrorIf(inFileBufferCount == 0, UNEXPECTED_ERROR);
		}
		if (pOut - 1024 > outBuffer)
		{
			if (oFlag)
				fatalErrorIf(1024 != fwrite(outBuffer, sizeof(uint8), 1024, outFile), FILE_WRITE_FAILED);
			else
				printBuffer(outBuffer, 1024);
			// Copy bits written past 1024 bytes to the start of the buffer and
			//    move pOut back by 1024 bytes.
			memcpy(outBuffer, outBuffer + 1024, sizeof(uint8) * 4);
			pOut -= 1024;
		}

		insertCodeIntoBuffer(&pOut, &bitsCount, &bufferBit, codeMap[*pIn]);
		count++;
	}

	if (fFlag)
		fclose(inFile);

	// If we have a partial byte left over we fill the remaining space with
	//    0's so we don't use whatever happens to be in memory when outputing
	if (bufferBit > 0)
	{
		HuffmanCode c = { 8 - bufferBit, 0 };
		uint64 t = 0; // We don't want to increment the bitCount
		insertCodeIntoBuffer(&pOut, &t, &bufferBit, c);
	}


	// Write remaining bytes to output
	if (oFlag)
	{
		uint64 remainingBytes = ((bitsCount + 7) / 8) % 1024;
		fatalErrorIf(remainingBytes != fwrite(outBuffer, sizeof(uint8), remainingBytes, outFile), FILE_WRITE_FAILED);
		fclose(outFile);
	}
	else
	{
		printBufferBits(outBuffer, bitsCount % 1024);
	}

	uint64 byteCount = ((double)bitsCount / 8 + 0.9); // Ceil
}

void computeAverageCodeLength(Uint8CountMap map, HuffmanCode* codeMap)
{
	double total = map.map[0] * codeMap[0].depth;
	for (uint8 i = 1; i > 0; ++i) // When the uint8 overflows i == 0
		total += map.map[i] * codeMap[i].depth;

	stats.bitsAfterEncoding = total;
	stats.averageCodeLength = (double)total / (double)map.count;
}


// main controls the program flow by parsing arguments and
//     deciding what functions should run from there.
int main(int argc, char** argv)
{
// Useful for debugging in Visual Studio, if the configuration
//    is set to debug _DEBUG is defined and the input can be
//    modified here instead of on the command line.
#ifdef _DEBUG
	/*argc = 4;
	char* args[] = { "", "-t", "-b", "Hello"};*/
	//argc = 6;
	//char* args[] = { "", "-t", "-s", "-b", "-d", "the quick brown fox jumps over the lazy dog"};
	//argc = 7;
	//char* args[] = { "", "-t", "-s", "-b", "-d", "-f", "../x64/Release/book.md" };
	argc = 6;
	char* args[] = { "", "-s", "-o", "../x64/Release/test.txt", "-f", "../x64/Release/Lorem.txt" };
	argv = args;
#endif
	// No arguments provided. Display usage message.
	if (argc == 1)
	{
		printf("No input was provided!\n\n");
		printUsage();
		return 0;
	}

	// Set the codepage so I can get the symbols I want in
	//    the console. On linux, it probably won't look right.
	// TODO: linux equivalent
#ifdef _WIN32
	SetConsoleCP(850);
	SetConsoleOutputCP(850);
#endif
	// Parse command line arguments.
	for (uint8 i = 1; i < argc; ++i)
	{
		if (argv[i][0] == '-')
		{
			switch (argv[i][1])
			{
			case 'f':
				fFlag = true;
				break;
			case 'd':
				dFlag = true;
				break;
			case 't':
				tFlag = true;
				break;
			case 'r':
				rFlag = true;
				break;
			case 's':
				sFlag = true;
				break;
			case 'b':
				bFlag = true;
				break;
			case 'n':
				nFlag = true;
				break;
			case 'o':
				oFlag = true;
				fatalErrorIf(++i >= argc, NO_OUTPUT_FILE);
				fatalErrorIf(argv[i][0] == '-', NO_OUTPUT_FILE);
				output = argv[i];
				break;
			default:
				fatalErrorIf(true, UNIMPLEMENTED_ERROR);
			}
		}
		else
		{
			fatalErrorIf(input != 0, MULTIPLE_INPUTS);
			input = argv[i];
		}
	}

	fatalErrorIf(rFlag, UNIMPLEMENTED_ERROR);

	if (nFlag && bFlag)
		printf("Warning: -b ignored because of -n\n");

	if (nFlag && oFlag)
		printf("Warning: -o ignored because of -n\n");

	// Perform requested actions.
	Uint8CountMap countMap = createUint8CountMap(input);
	HuffmanTree tree = createUint8HuffmanTree(&countMap);
	HuffmanCode codeMap[256] = { 0 };
	parseHuffmanTree(codeMap, &tree);

	if(sFlag)
		computeAverageCodeLength(countMap, codeMap);

	bool firstSection = true;

	if (!nFlag)
	{
		firstSection = false;
		if (oFlag && !nFlag)
			printf("Encoding Message...\n");
		else
			printf("Encoded Message: \n");

		encodeMessage(codeMap, countMap.count);

		if (oFlag)
			printf("Done.\n");
		else
			printf("\n");
	}

	if (tFlag)
	{
		if (firstSection) firstSection = false;
		else printf("\n");

		printf("Huffman Tree:\n");
		printHuffmanTree(codeMap, &tree);
	}

	if (dFlag)
	{
		if (firstSection) firstSection = false;
		else printf("\n");

		printf("Dictionary:");
		for (uint32 i = 0; i < 256; ++i)
		{
			if (countMap.map[i] > 0)
			{
				printf("\n%3u: ", i);
				printHuffmanCode(codeMap[i]);
			}
		}
		printf("\n");
	}

	if (sFlag)
	{
		if (firstSection) firstSection = false;
		else printf("\n");

		printf("Statistics:\n");
		printf("----  Input  ----\n");
		printf("Size Before Encoding : %llu Byte/s\n", stats.bytesBeforeEncoding);
		printf("Shannon Entropy      : %.3f\n", stats.shannonEntropy);

		printf("\n---- Output  ----\n");
		printf("Size After Encoding  : %llu Byte/s", stats.bitsAfterEncoding / 8);
		if (stats.bitsAfterEncoding % 8 > 0)
			printf(" and %llu Bit/s\n", stats.bitsAfterEncoding % 8);
		else
			printf("\n");
		double compressionRatio = (double)(stats.bitsAfterEncoding) / (double)(stats.bytesBeforeEncoding * 8);
		printf("Compression Ratio    : %.3f (%.1f%%)\n", compressionRatio, compressionRatio * 100.0);

		printf("\n---- General ----\n");
		printf("Average Code Length  : % .3f bits\n", stats.averageCodeLength);
	}



	destroyHuffmanTree(&tree);
}