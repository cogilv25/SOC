// This application is able to compress and decompress strings or files
// using Huffman encoding. Additionally using flags you can show the
// intermediate tree and dictionary, or see statistics about the input
// and output such as compression ratio and shannon entropy. Running
// the program with no arguments will provide full usage guidance.
// 
// TODO: Feature List
//--------------- Minimum -------------------
// - Input message or text file
//     - Flag for file -f
// - Construct binary Huffman Tree
// - Encode the input message / file
// - Output the encoded message
//     - Flag to output to a file -o
// - Output the dictionary
//     - Flag to output dictionary -d
//------------- Reasonable ------------------
// - Decoding messages or text files
//     - Flag for decode -r (reverse)
// - Additional statistics
//     - Flag for statistics -s
//     - Compression ratio inc/dis dictionary
//     - ?
// - How efficiently does the algorith compress different data types
// - How does the algorithm perform on very large datasets (books, csv, images, audio)
// - How does it perform on pre-compressed data. (ADD)
// - Shannons entropy.
//     - Of the input
//     - Compared to the output
//------------- Difficult  ------------------
// - Visualization of Huffman tree
// - Dictionary transmission protocols (ADD)
// - Use Hoffman code's for words in long texts (ADD)
// - Use Hoffman code's for variable sized data (Byte, short, int, long) (ADD)
// - Recursive Hoffman encoding? (ADD)
//
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// This is defined in Visual Studio, other compilers may or may not
//    define it..
#ifdef _WIN32
#include <Windows.h>
#endif

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef unsigned long long uint64;


typedef struct TreeNode
{
	uint64 count;
	struct TreeNode* left;
	union
	{
		struct TreeNode* p;
		uint8 uint8Value;
		uint16 uint16Value;
		uint32 uint32Value;
		uint64 uint64Value;
	} right;
} TreeNode;

typedef struct
{
	uint64 map[256];
	uint64 count;
	uint16 uniqueCount;
} Uint8CountMap;

typedef struct
{
	TreeNode* root;
	Uint8CountMap* map;
} HuffmanTree;

typedef struct
{
	// This is not a simple mapping but using it's functions allows mapping
	// of any dictionary, even the worst case with a single 255bit code.
	uint8 positions[256];
	uint8 depths[256];
	uint8 map[256];
} HuffmanCodeMap;

typedef enum
{
	CALLOC_FAILED = 0,
	FILE_NON_EXISTENT = 1,
	RECURSION_LIMIT_EXCEEDED = 2,
	UNIMPLEMENTED_ERROR = 3,
	MULTIPLE_INPUTS = 4,
	UNEXPECTED_ERROR = 5,
	TEMP_RECURSION_LIMIT = 6
} ErrorCode;

const char* ErrorMessages[] =
{
	"A call to calloc failed! this should only happen if the OS can't return a block the size requested. "
	"Either your memory is completely full, incredibly fragmented, or something odd has happened!",
	"Filepath entered does not point to a file.",
	"Printing only supports huffman trees with a depth up to 64. It is unlikely this would be readable anyway!",
	"The feature you are trying to use is currently unimplemented!",
	"Only one input string is supported! Multiple were provided, if the input contains spaces, surround it with quotes.",
	"An infeasible error has occured, please try again, if this continues contact the creator of this program.",
	"Temporary maximum depth is 16bits due to a previously un-realised limitation."
};

void printUsage()
{
	printf("usage: comp [-b] [-d] [-f] <input>  \n\n");
	printf("<input> is interpreted as a string unless -f is provided.\n\n");
	printf("Flags: \n");
	printf("    -f Interpret <input> as a filepath and compress the file it points to.\n");
	printf("    -b Print the encoded message as a binary string.\n");
	printf("    -d Output the Huffman code dictionary internally generated by the program.\n");
	//printf("    -s Generate and print additional statistics about the input, internal structures, and output\n");
	//printf("    -t Output the Huffman tree internally generated to the console. (large trees may not display correctly)\n");
	//printf("    -r Decode the input, as this does not produce a Huffman tree the t flag is ignored.\n");
	// [-o <filepath>]
}

// Prints the error associated with the error code if the condition
//     is true and returns the condition. Cleans up error reporting.
bool printErrorIf(bool condition, ErrorCode error)
{
	if (condition)
		printf("Error: %s\n", ErrorMessages[error]);

	return condition;
}

// Basically an Assert with re-usable error codes rather than strings.
void fatalErrorIf(bool condition, ErrorCode error)
{
	if (printErrorIf(condition, error))
		exit(-1);
}

HuffmanTree createUint8HuffmanTree(Uint8CountMap* map)
{
	// Maximum nodes = n * 2
	TreeNode* nodes = calloc(map->uniqueCount * 2, sizeof(TreeNode));
	fatalErrorIf(nodes == NULL, CALLOC_FAILED);

	uint16 count = 0;
	uint8 symbol = 0;
	for (; count < map->uniqueCount; ++symbol)
	{
		// Find next symbol
		for (; symbol < 256; ++symbol)
			if (map->map[symbol] > 0) break;

		// Find insertion point
		uint8 i = count;
		for (; i > 0 && map->map[symbol] < nodes[i - 1].count; --i)
			memcpy(nodes + i, nodes + i - 1, sizeof(TreeNode));

		// Insert element
		nodes[i].count = map->map[symbol];
		nodes[i].left = 0;
		nodes[i].right.uint8Value = symbol;
		++count;
	}

	// Ok, so we are going to start using the nodes array from both ends.
	//    From the end of the array going backwards (right array) are the 
	//    sorted nodes from smallest to largest count and from the start
	//    of the array going forwards (left array) are the unsorted nodes 
	//    again from smallest to largest count. We can guarantee these will
	//    never overlap due to the binary tree at max having 2n nodes. Once
	//    the left array has 1 item we are done.
	uint16 rightTail = map->uniqueCount * 2 - 1;
	for (;count > 1; --count)
	{
		// Copy 2 elements to right array.
		memcpy(&nodes[rightTail--], nodes, sizeof(TreeNode));
		memcpy(&nodes[rightTail--], nodes + 1, sizeof(TreeNode));
		// Move left array left by 2 elements
		memcpy(nodes, nodes + 2, sizeof(TreeNode) * (count - 2));

		// Find insertion point
		uint64 newNodeCount = nodes[rightTail + 1].count + nodes[rightTail + 2].count;
		uint8 i = count - 2;
		for (; i > 0 && newNodeCount < nodes[i - 1].count; --i)
			memcpy(nodes + i, nodes + i - 1, sizeof(TreeNode));

		// Insert element
		nodes[i].count = newNodeCount;
		nodes[i].left = nodes + rightTail + 1;
		nodes[i].right.p = nodes + rightTail + 2;
	}

	HuffmanTree tree;
	tree.root = nodes;
	tree.map = map;
	return tree;
}

void destroyHuffmanTree(HuffmanTree* tree)
{
	free(tree->root);
}

Uint8CountMap createUint8CountMap(const char* string, bool isFile)
{
	Uint8CountMap map = { 0 };

	if (!isFile)
	{
		for (const uint8* p = string; *p != '\0'; ++p)
		{
			
			if(map.map[*p]++ == 0) // Count occurances of *p
				++map.uniqueCount; // Count unique uint8's in string
			++map.count;           // Count total uint8's in string
		}
	}
	else
	{
		FILE* f = fopen(string, "rb");

		// No microsoft, f couldn't be 0 because we are checking right here
		//     Visual Studio has really gone downhill the last ~10 years...
		fatalErrorIf(f == NULL, FILE_NON_EXISTENT);
		
		uint8 buffer[1024];
		size_t bytesRead = fread(buffer, 1, 1024, f);
		while (bytesRead > 0)
		{
			for (int i = 0; i < bytesRead; ++i)
			{
				if(map.map[buffer[i]]++ == 0)// Count occurances of buffer[i] 
					++map.uniqueCount;       // Count unique uint8's in string
				++map.count;                 // Count total uint8's in string
			}

			if (bytesRead != 1024) break;

			bytesRead = fread(buffer, 1, 1024, f);
		}
		fclose(f);
	}
	return map;
}

void printHuffmanCode(uint32 depth, uint32 code)
{
	for (uint32 i = 1; i <= depth; ++i)
	{
		printf((code & (1 << (depth - i))) > 0 ? "1" : "0");
	}
}

void _recurseUint8HuffmanTree(uint32* m, TreeNode* n, uint32 depth, uint32 code, bool print, uint64 lines)
{
	fatalErrorIf(depth > 16, TEMP_RECURSION_LIMIT);
	if (print)
	{
		fatalErrorIf(depth > 64, RECURSION_LIMIT_EXCEEDED);
		if (depth > 0)
		{
			for (uint32 i = depth - 1; i > 0; --i)
			{
				if ((lines & ((uint64)1 << i)) != 0)
					printf(" %c ", 179);
				else
					printf("   ");
			}

			// Mod2 but we want to flip it so that it's 1 when it would
			// have been 0 and vice versa as it makes the logic easier.
			uint32 mod = (code % 2 + 1) % 2;

			// Branchless programming, we are changing what character we
			//    draw in the table based on the value of mod, where if
			//    mod == 0 we are at the start of a right branch.
			uint8 c = 192 + mod * 3;

			// Again, the next line will be 1 depth deeper, if it's a left
			//    branch we need to draw an up-down line otherwise a space.
			//    Essentialy lines is a bitmap that tells us what to draw.
			lines = (lines + mod) << 1;
			printf(" %c ", c);
		}
		if(n->left != 0)
			printf(" %llu\n", n->count);
		else
		{
			printf("%llu = (Symbol: %u, Code: ", n->count, n->right.uint8Value);
			printHuffmanCode(depth, code);
			printf(")\n");
		}
	}
	
	// Worst case depth is 255 bits..... So we can store the depth in a uint8, however,
	//    a 255 bit depth code would require 255 bits or 1 bit less than 32Bytes! This is
	//    8KB for a full dictionary, although we couldn't have a full dictionary with that
	//    depth as that is worst case and only 1 code would have that depth... the average
	//    would be close to the shannon entropy and the worst case there is 8 bits.
	if (n->left == 0)
		m[n->right.uint8Value] = (depth << 16) + code;
	else
	{
		_recurseUint8HuffmanTree(m, n->left, ++depth, code << 1, print, lines);
		_recurseUint8HuffmanTree(m, n->right.p, depth, (code << 1) + 1, print, lines);
	}
		
}


void parseUint8HuffmanTree(uint32 * map, HuffmanTree* tree, bool printTree, bool collectStatistics)
{
	// We have set a hard limit on huffman tree rendering depth of 64 here..
	//    honestly that would be unreadable anyway and 64 is probably too much 
	//    although it's a reasonable max and it means we can use a 64bit uint to 
	//    help with pretty rendering.
	_recurseUint8HuffmanTree(map, tree->root, 0, 0, printTree, 0);
}

void insertCodeIntoBuffer(uint8** buffer, uint64* bitCount, uint8* bufferBit, uint16 depth, uint16 code)
{
	for (uint8 bit = depth; bit > 0; --bit)
	{
		// Append a single bit of the code to the buffer
		**buffer = (**buffer << 1) + ((code >> (bit - 1)) & (uint16)1);
		++(*bufferBit);
		++(*bitCount);

		if (*bufferBit < 8) continue;

		// If we reach the end of a byte move to the next byte in memory
		++(*buffer);
		*bufferBit = 0;
	}
}

// TODO: Files
void encodeMessage(uint64* buffer, uint32* codeMap, uint8* input, uint64 characterCount, bool file, bool print, bool binaryPrint)
{
	// Endianness makes this a little bit of a pain, ideally we would
	// insert more than 1bit at a time but, it's very fiddly.
	uint8* bufferLocation = buffer;
	uint8 bufferBit = 0;
	uint64 bitsCount = 0;
	uint64 count = 0;
	FILE* f = 0;
	uint8 fileBuffer[1024];
	uint16 fileBufferSize = 0;
	uint8* p = input;

	if (file)
	{
		f = fopen(input, "rb");
		fatalErrorIf(f == NULL, FILE_NON_EXISTENT);
		p = fileBuffer;
		fileBufferSize = fread(fileBuffer, sizeof(uint8), 1024, f);
	}

	for (; count < characterCount; ++p)
	{
		if (file && p >= (fileBuffer + fileBufferSize))
		{
			fileBufferSize = fread(fileBuffer, sizeof(uint8), 1024, f);
			p = fileBuffer;

			// I think this would only happen if the file changed between
			//    us previously reading it and now...
			fatalErrorIf(fileBufferSize == 0, UNEXPECTED_ERROR);
		}
		uint16 depth = codeMap[*p] >> 16;
		uint16 code = (codeMap[*p] << 16) >> 16;

		insertCodeIntoBuffer(&bufferLocation, &bitsCount, &bufferBit, depth, code);
		count++;
	}

	if (file)
		fclose(f);

	uint64 byteCount = bitsCount / 8;

	bufferLocation = buffer;
	if (print)
	{
		if (binaryPrint)
		{
			for (uint64 i = 0; i < byteCount; ++i)
				printHuffmanCode(8, *(bufferLocation + i));
			printHuffmanCode(bufferBit, *(bufferLocation + byteCount));
		}
		else
		{
			for (uint64 i = 0; i < (byteCount + (bufferBit > 0 ? 1 : 0)); ++i)
				printf("%c", *(bufferLocation + i));
		}


		printf("\n\nSize: %llu Bits or %llu Bytes", bitsCount, byteCount);
		if (bufferBit > 0)
			printf(" and %u Bits", bufferBit);
		printf("\n");
	}

}

// Flags and command line argument state.
bool dFlag = false;
bool tFlag = false;
bool oFlag = false; const char* oFilePath;
bool fFlag = false;
bool rFlag = false;
bool sFlag = false;
bool bFlag = false;
const char* input = 0;
// main controls the program flow by parsing arguments and
//     deciding what functions should run from there.
int main(int argc, char** argv)
{
// Useful for debugging in Visual Studio, if the configuration
//    is set to debug _DEBUG is defined and the input can be
//    modified here instead of on the command line.
#ifdef _DEBUG
	argc = 6;
	char* args[] = { "", "-t", "-b", "-d", "-f", "../x64/Release/photo.jpg"};
	argv = args;
#endif
	// No arguments provided. Display usage message.
	if (argc == 1)
	{
		printf("No input was provided!\n\n");
		printUsage();
		return 0;
	}

	// Set the codepage so I can get the symbols I want in
	//    the console. On linux, it probably won't look right.
	// TODO: linux equivalent
#ifdef _WIN32
	SetConsoleCP(850);
	SetConsoleOutputCP(850);
#endif
	// Parse command line arguments.
	for (uint8 i = 1; i < argc; ++i)
	{
		if (argv[i][0] == '-')
		{
			switch (argv[i][1])
			{
			case 'f':
				fFlag = true;
				break;
			case 'd':
				dFlag = true;
				break;
			case 't':
				tFlag = true;
				break;
			case 'r':
				rFlag = true;
				break;
			case 's':
				sFlag = true;
				break;
			case 'b':
				bFlag = true;
				break;
			default:
				fatalErrorIf(true, UNIMPLEMENTED_ERROR);
			}
		}
		else
		{
			fatalErrorIf(input != 0, MULTIPLE_INPUTS);
			input = argv[i];
		}
	}

	fatalErrorIf(rFlag || oFlag, UNIMPLEMENTED_ERROR);

	// Perform requested actions.
	Uint8CountMap countMap = createUint8CountMap(input, fFlag);
	HuffmanTree tree = createUint8HuffmanTree(&countMap);
	uint32 codeMap[256] = { 0 };
	parseUint8HuffmanTree(codeMap, &tree, tFlag, sFlag);

	uint64* buffer = calloc(1024, 1024 * 5); // 1MiB
	fatalErrorIf(buffer == NULL, CALLOC_FAILED);

	printf("Encoded Message: \n");
	encodeMessage(buffer, codeMap, input, countMap.count, fFlag, true, bFlag);

	if (dFlag)
	{
		printf("\nDictionary:\n");
		for (uint32 i = 0; i < 256; ++i)
		{
			if (countMap.map[i] > 0)
			{
				printf("%3u: ", i);
				printHuffmanCode(codeMap[i] >> 16, (codeMap[i] << 16) >> 16);
				printf("\n");
			}
		}
	}

	destroyHuffmanTree(&tree);
}